#!/usr/bin/env ruby

require 'rubygems'
require 'notes'
require 'optparse'
require 'paint'
require 'find'

interrupted = false
gfm = false
verbose = false
color = STDOUT.tty?
usage = 'Usage: notes [OPTION]... [FILE]...'
tags = Notes::TAGS.dup

trap("INT") { interrupted = true }

ARGV.options do |o|
  o.version = Notes::VERSION
  o.banner = usage
  o.on(      '--no-todo',    'Do not search TODO tags')  { tags -= ['TODO'] }
  o.on(      '--no-fixme',   'Do not search FIXME tags') { tags -= ['FIXME'] }
  o.on(      '--no-xxx',     'Do not search XXX tags')   { tags -= ['XXX'] }
  o.on('-a', '--tag=TAG',    'Search TAG tags')          { |tag| tags |= [tag] }
  o.on(      '--[no-]color', 'Do [not] colorize output') { |flag| color = flag }
  o.on('-g', '--gfm',        'Print in GFM format')      { gfm = true }
  o.on('-v', '--verbose',    'Print more messages')      { verbose = true }
end

begin
  ARGV.options.parse!
  if ARGV.empty?
    paths = '.'
  else
    paths = ARGV.map { |p| File.exist? p or raise Errno::ENOENT, p ; p }
  end
rescue => e
  STDERR.puts "notes: #{e.message}"
  STDERR.puts usage
  STDERR.puts "Try `notes --help' for more information."
  exit 1
end

# grep-style display
color or Paint.mode = 0
c = Paint[':', :cyan]
format = Paint['%s', :magenta] + c + Paint['%s', :green] + c + '%s' + c + "%s\n"
colors = {
  'TODO'  => 'green',
  'FIXME' => 'yellow',
  'XXX'   => 'red',
  :custom => 'cyan'
}

greplike_callback = lambda do |note|
  tag = Paint[note.tag, colors[note.tag] || colors[:custom], :bold]
  printf(format, note.file, note.line, tag, note.text.rstrip)
end

# GFM
gfm_callback = lambda do |note|
  puts "  - [ ] #{ note.text.strip }"
end

scanner = Notes::Scanner.new
scanner.tags = tags
scanner.callback = gfm ? gfm_callback : greplike_callback

Find.find(*paths) do |path|
  unless paths.include? path
    Find.prune if File.basename(path).start_with? '.'
  end
  next if File.directory? path

  begin
    scanner.scan_file(path)
  rescue Errno::ENOENT => e
    STDERR.puts "notes: #{e.message} (broken symlink?)" if verbose
  rescue => e
    STDERR.puts "notes: #{path}: #{e.message}" if verbose
  end
  exit if interrupted
end

exit
